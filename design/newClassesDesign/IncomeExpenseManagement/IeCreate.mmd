%%{
    init: {
        "theme":"base",
        "themeVariables": {
            'labelBoxBorderColor': '#ff0000'
        },
        "sequence": { 
            "wrap": true, 
            "width": 200 
        } 
    }
}%%
sequenceDiagram
    participant Client
    participant Sec as Security
    participant Router as BankRouter
    box orange Controller
        participant BaseCont as BaseController
        participant Cont as TransactionController extends BaseController
    end
    participant PGClient as PostgreSQLClient
    participant BaseModel as BaseModel 
    participant Model as TransactionModel extends BaseModel
    participant ContainsModel as ContainsModel extends BaseModel
    participant BankAccountModel as BankAccountModel extends BaseModel
    participant DebtModel as DebtModel extends BaseModel
    participant Redis as RedisCache
    
    Client->>+Router: POST /transactions/ (create Transaction)
    Note over Sec, Router: this method defined in UserManagement/read.mmd
    Router->>+Sec: verifyToken(req)
    alt Token decode error | Token expired | Invalid token
        Sec-->>Router: next(new UnauthorizedError('Invalid credentials'))
        Router-->>Client: ğŸ”´401, "Could not validate credentials"
    end
    Sec-->>-Router: decoded user object 

    Note over Sec, Router: this method defined in UserManagement/create.mmd
    Router->>Router: MethodValidator(allowedMethods)
    opt path not available
        Router-->>Client: ğŸ”´404, "<path> not available"
    end
    opt method not allowed
        Router-->>Client: ğŸ”´405, "<method> not allowed for <path>"
    end

    Router->>+Cont: createTransaction(req, res, next)
    Cont->>Cont: Destructuring req.body
    Note over Cont: requiredFields = ['transactionDateTime', 'type', 'amount', 'category', 'senderBankAccount', 'receiverBankAccount']
    Cont->>+BaseCont: verifyField(req.body, requiredFields)
    opt missing required fields
        BaseCont-->>Cont: throw new Error('<field> is required')
        Cont-->>Router: next(new BadRequestError(error.message))
        Router-->>Client: ğŸ”´400, "<field> is required"
    end
    BaseCont->>-Cont: return true

    Note over Cont, BaseCont: this method defined in UserManagement/read.mmd
    Cont->>+BaseCont: getCurrentUser(req)
    BaseCont-->>-Cont: return User object
    opt user not found
        Cont-->>Router: next(new NotFoundError('User not found'))
        Router-->>Client: ğŸ”´404, "User not found"
    end

    Note over Cont: verifying selected bank is exist
    alt transaction type is "income"
        Note over Cont, BankAccountModel: this method defined in BankAccountManagement/ReadOne.mmd
        Cont->>+BankAccountModel: findById(receiverBankAccount)
        BankAccountModel-->>-Cont: return ReceiverBankAccount
        opt receiver bank account not found
            Cont-->>Router: next(new NotFoundError('Receiver bank account not found'))
            Router-->>Client: ğŸ”´404, "Receiver bank account not found"
        end
    else transaction type is "expense"
        Note over Cont, BankAccountModel: this method defined in BankAccountManagement/ReadOne.mmd
        Cont->>+BankAccountModel: findById(senderBankAccount)
        BankAccountModel-->>-Cont: return SenderBankAccount
        opt sender bank account not found
            Cont-->>Router: next(new NotFoundError('Sender bank account not found'))
            Router-->>Client: ğŸ”´404, "Sender bank account not found"
        end
    else transaction type is "internal-transfer"
        Note over Cont, BankAccountModel: this method defined in BankAccountManagement/ReadOne.mmd
        Cont->>+BankAccountModel: findById(receiverBankAccount)
        BankAccountModel-->>-Cont: return ReceiverBankAccount
        opt receiver bank account not found
            Cont-->>Router: next(new NotFoundError('Receiver bank account not found'))
            Router-->>Client: ğŸ”´404, "Receiver bank account not found"
        end
        Note over Cont, BankAccountModel: this method defined in BankAccountManagement/ReadOne.mmd
        Cont->>+BankAccountModel: findById(senderBankAccount)
        BankAccountModel-->>-Cont: return SenderBankAccount
        opt sender bank account not found
            Cont-->>Router: next(new NotFoundError('Sender bank account not found'))
            Router-->>Client: ğŸ”´404, "Sender bank account not found"
        end
    end

    Cont->>+PGClient: beginTransaction()
    PGClient-->>-Cont: transaction started

    alt transaction type is "income"
        Cont->>+BankAccountModel: updateBalance(userEmail, receiverBankAccount, +amount)
        opt update failure
            BankAccountModel-->>Cont: throw error
            Cont->>+PGClient: rollback()
            PGClient-->>-Cont: transaction rolled back
            Cont-->>Router: next(new Error('Failed to update receiver balance'))
            Router-->>Client: ğŸ”´500, "Failed to update receiver balance"
        end
        BankAccountModel-->>-Cont: updated BankAccount object (staged)
    else transaction type is "expense"
        Cont->>+BankAccountModel: updateBalance(userEmail, senderBankAccount, -amount)
        opt update failure
            BankAccountModel-->>Cont: throw error
            Cont->>+PGClient: rollback()
            PGClient-->>-Cont: transaction rolled back
            Cont-->>Router: next(new Error('Failed to update sender balance'))
            Router-->>Client: ğŸ”´500, "Failed to update sender balance"
        end
        BankAccountModel-->>-Cont: updated BankAccount object (staged)

        opt debt payment
            Cont->>+DebtModel: updateLoanBalance(userEmail, debtKey, -amount)
            opt update failure
                DebtModel-->>Cont: throw error
                Cont->>+PGClient: rollback()
                PGClient-->>-Cont: transaction rolled back
                Cont-->>Router: next(new Error('Failed to update debt'))
                Router-->>Client: ğŸ”´500, "Failed to update debt"
            end
            DebtModel-->>-Cont: updated Loan object (staged)
        end
    end

    Cont->>+Model: insertTransaction({userEmail, transactionUUID, transactionDateTime, category, type, amount, note})
    opt insert failure
        Model-->>Cont: throw error
        Cont->>PGClient: rollback()
        PGClient-->>Cont: transaction rolled back
        Cont-->>Router: next(new Error('Failed to store transaction'))
        Router-->>Client: ğŸ”´500, "Failed to store transaction"
    end
    Model-->>-Cont: return insertedTransaction object (staged)

    alt transaction type is "income"
        Cont->>+ContainsModel: insertContains({senderBankAccount, transactionUUID, 'receiver'})
        opt insert failure
            ContainsModel-->>Cont: throw error
            Cont->>PGClient: rollback()
            PGClient-->>Cont: transaction rolled back
            Cont-->>Router: next(new Error('Failed to store contains'))
            Router-->>Client: ğŸ”´500, "Failed to store contains"
        end
        ContainsModel-->>-Cont: return insertContains object (staged)
    else transaction type is "expense"
        Cont->>+ContainsModel: insertContains({senderBankAccount, transactionUUID, 'sender'})
        opt insert failure
            ContainsModel-->>Cont: throw error
            Cont->>PGClient: rollback()
            PGClient-->>Cont: transaction rolled back
            Cont-->>Router: next(new Error('Failed to store contains'))
            Router-->>Client: ğŸ”´500, "Failed to store contains"
        end
        ContainsModel-->>-Cont: return insertContains object (staged)
    else transaction type is "internal_transfer"
        Cont->>+ContainsModel: insertContains({senderBankAccount, transactionUUID, 'sender'})
        opt insert failure
            ContainsModel-->>Cont: throw error
            Cont->>PGClient: rollback()
            PGClient-->>Cont: transaction rolled back
            Cont-->>Router: next(new Error('Failed to store contains'))
            Router-->>Client: ğŸ”´500, "Failed to store contains"
        end
        ContainsModel-->>-Cont: return insertContains object (staged)
        Cont->>+ContainsModel: insertContains({receiverBankAccount, transactionUUID, 'receiver'})
        opt insert failure
            ContainsModel-->>Cont: throw error
            Cont->>PGClient: rollback()
            PGClient-->>Cont: transaction rolled back
            Cont-->>Router: next(new Error('Failed to store contains'))
            Router-->>Client: ğŸ”´500, "Failed to store contains"
        end
        ContainsModel-->>-Cont: return insertContains object (staged)
    end

    Cont->>PGClient: commit()
    PGClient-->>Cont: transaction committed

    Note over Cont, Redis: Async operation
    Cont-)+Redis: Cache transaction details (Join tables Transaction, Contains, BankAccount)

    Cont->>Cont: formatResponse(201, 'Transaction successful', insertedTransaction object)
    Cont-->>-Router: return formatted response
    Router-->>-Client: ğŸŸ¢201, "Transaction successful", insertedTransaction object
    
